//  Rincao Microcontroller Unit

//  Autor: Caio César Gonçalves de Oliveira
//  TCIC-II
//
//  Data de início: 01/11/2017
//  Data de término: 05/07/2018
//
//  Data da ultima atualização: 04/10/2018



//bibliotecas do sensor de temperatura
#include  <OneWire.h>
#include <DallasTemperature.h>

void setup_temp(){
//setup sensor temperatura
OneWire ds(2);
int tempo = 6000; //tempo milisegundos
}



void setup() {
  
 // setar velocidade do equipamento (*****):
 Serial.begin(115200);

}

void temperature(){

 
              byte i;
              byte present = 0;
              byte type_s;
              byte data[12];
              byte addr[8];
              float celsius, fahrenheit;

 
                      if ( !ds.search(addr)) {
                      /// Serial.println("No more addresses.");
                      /// Serial.println();
                      ds.reset_search();
                      delay(250);
                      return;
                      }
 
             if ( ds.search(addr)) {
             Serial.println("fallo");
             }
 
             for( i = 0; i < 8; i++) { 
             addr[i];
             }
 
             if (OneWire::crc8(addr, 7) != addr[7]) {
             Serial.println("CRC is not valid!");
             return;
             }

 
                            // the first ROM byte indicates which chip
                            switch (addr[0]) {
            
                                       case 0x10:
 
                                              type_s = 1;
                                              break;
                                        
                                       case 0x28:
 
                                              type_s = 0;
                                              break;
                                       
                                       case 0x22:
           
                                      // Serial.println(" Chip = DS1822");
                                              type_s = 0;
                                              break;
                                              
                                       default:
 
                                              Serial.println("Device is not a DS18x20 family device.");
                                              Serial.println("Paso 4");
                                              return;
                             } 
 
             ds.reset();
             ds.select(addr);
             ds.write(0x44, 1); 
  
             delay(tempo); 
 
             present = ds.reset();
             ds.select(addr); 
             ds.write(0xBE); 
 
              //Serial.println("Paso 7");
 
                                      for ( i = 0; i < 9; i++) { 
                                            
                                            
                                            data[i] = ds.read();
                                      }
 
             OneWire::crc8(data, 8); 
 
             int16_t raw = (data[1] << 8) | data[0];

                                      if (type_s) {
                                            
                                            raw = raw << 3; 
                                            
                                      if (data[7] == 0x10) {
                                         
                                            raw = (raw & 0xFFF0) + 12 - data[6]; }
                                      } 
                                      
                                      else {
                                        
                                            byte cfg = (data[4] & 0x60);
 
                                      if (cfg == 0x00) raw = raw & ~7; // 9 bit resolution, 93.75 ms
                                      
                                      else if (cfg == 0x20) raw = raw & ~3; // 10 bit res, 187.5 ms
                                      
                                      else if (cfg == 0x40) raw = raw & ~1; // 11 bit res, 375 ms
                                      
                                      }
 
             float celsius_web; 
             celsius = (float)raw / 16.0;
 
             if (isnan(celsius)) {
             Serial.println("isnan");
             }
 
             Serial.print("Temperatura: ");
             Serial.print(celsius); 
             Serial.println("C");
  
}

void loop_temp() {
  // put your main code here, to run repeatedly:
 temperature(); 
 delay(tempo);
}


//bibliotecas do sensor de vibracao
#include <Wire.h>
#include <SparkFun_MMA8452Q.h>


void setup_vib(){
//setup sensor de vibracão
//Cria uma instancia do MMA8452 chamada acelerometro
//com endereco I2C 0x1C (pino SA0 em LOW/Desligado)
MMA8452Q acelerometro(0x1C);
}


void setup(){
 Serial.println("Teste de comunicacao MMA8452");
  //Inicializa o acelerometro com o valores padrao de +/-2g e
  //saida de 800 Hz
  acelerometro.init();
  //Utilize a linha abaixo para inicializar o acelerometro com
  //+/-2g, 4g, or 8g, usando SCALE_2G, SCALE_4G, ou SCALE_8G
  //acelerometro.init(SCALE_4G);
  //Utilize a linha abaixo para determinar tambem a frequencia
  //de saida do acelerometro (padrao de 800 Hz), utilizando
  //como segundo parametro ODR_800 (800 Hz), ODR_400 (400 Hz),
  //ODR_200 (200 Hz), ODR_100 (100 Hz), ODR_50 (50 Hz),
  //ODR_12 (12.5 Hz), ODR_6 (6.25 Hz), ou ODR_1 (1.56 Hz)  
  //acelerometro.init(SCALE_8G, ODR_6);
}


void loop_aceler()
{
  //A linha abaixo aguarda o envio de novos dados pelo acelerometro
  if (acelerometro.available())
  {
    //Efetua a leitura dos dados do sensor
    acelerometro.read();
    //acelerometro.read() atualiza dois grupos de variaveis:
    //* int x, y, e z armazena o valor de 12 bits lido do
    //acelerometro
    // * float cx, cy, e cz armazena o calculo da aceleracao
    //dos valores de 12 bits. Essas variaveis estao em
    //unidades de "g"
    
    //Mostra as coordenadas lidas do sensor
    printCalculatedAccels();
    
    //Selecione a linha abaixo para mostra os valores digitais
    //printAccels();
    
    //Mostra a orientacao (retrato/paisagem/flat)
    printOrientation();
    Serial.println();
  }
}

void printAccels()
{
  Serial.print(acelerometro.x, 3);
  Serial.print("\t");
  Serial.print(acelerometro.y, 3);
  Serial.print("\t");
  Serial.print(acelerometro.z, 3);
  Serial.print("\t");
}

void printCalculatedAccels()
{ 
  
  Serial.print(acelerometro.cx, 3);
  Serial.print("\t");
  Serial.print(acelerometro.cy, 3);
  Serial.print("\t");
  Serial.print(acelerometro.cz, 3);
  Serial.print("\t");
}

void printOrientation()
{
  //acelerometro.readPL() retorna um byte contendo informacoes sobre
  //a orientacao do sensor (retrato/paisagem)
  //PORTRAIT_U (Retrato Up/Para cima), PORTRAIT_D (Retrato Down/Para Baixo), 
  //LANDSCAPE_R (Paisagem right/direita), LANDSCAPE_L (Paisagem left/esquerda)
  //e LOCKOUT (bloqueio)
  byte pl = acelerometro.readPL();
  switch (pl)
  {
  case PORTRAIT_U:
    Serial.print("Retrato Para Cima");
    break;
  case PORTRAIT_D:
    Serial.print("Retrato Para Baixo");
    break;
  case LANDSCAPE_R:
    Serial.print("Paisagem Direita");
    break;
  case LANDSCAPE_L:
    Serial.print("Paisagem Esquerda");
    break;
  case LOCKOUT:
    Serial.print("Plano");
    break;
    }
  }
